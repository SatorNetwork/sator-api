// Code generated by sqlc. DO NOT EDIT.
// source: watcher_transactions.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const cleanTransactions = `-- name: CleanTransactions :exec
DELETE FROM watcher_transactions
`

func (q *Queries) CleanTransactions(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanTransactionsStmt, cleanTransactions)
	return err
}

const getAllTransactions = `-- name: GetAllTransactions :many
SELECT id, serialized_message, latest_valid_block_height, account_aliases, tx_hash, status, updated_at, created_at, retries FROM watcher_transactions
`

func (q *Queries) GetAllTransactions(ctx context.Context) ([]WatcherTransaction, error) {
	rows, err := q.query(ctx, q.getAllTransactionsStmt, getAllTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WatcherTransaction
	for rows.Next() {
		var i WatcherTransaction
		if err := rows.Scan(
			&i.ID,
			&i.SerializedMessage,
			&i.LatestValidBlockHeight,
			pq.Array(&i.AccountAliases),
			&i.TxHash,
			&i.Status,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Retries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByStatus = `-- name: GetTransactionsByStatus :many
SELECT id, serialized_message, latest_valid_block_height, account_aliases, tx_hash, status, updated_at, created_at, retries FROM watcher_transactions
WHERE status = $1
`

func (q *Queries) GetTransactionsByStatus(ctx context.Context, status string) ([]WatcherTransaction, error) {
	rows, err := q.query(ctx, q.getTransactionsByStatusStmt, getTransactionsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WatcherTransaction
	for rows.Next() {
		var i WatcherTransaction
		if err := rows.Scan(
			&i.ID,
			&i.SerializedMessage,
			&i.LatestValidBlockHeight,
			pq.Array(&i.AccountAliases),
			&i.TxHash,
			&i.Status,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Retries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerTransaction = `-- name: RegisterTransaction :one
INSERT INTO watcher_transactions (
    serialized_message,
    latest_valid_block_height,
    account_aliases,
    tx_hash,
    status
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
) RETURNING id, serialized_message, latest_valid_block_height, account_aliases, tx_hash, status, updated_at, created_at, retries
`

type RegisterTransactionParams struct {
	SerializedMessage      string   `json:"serialized_message"`
	LatestValidBlockHeight int64    `json:"latest_valid_block_height"`
	AccountAliases         []string `json:"account_aliases"`
	TxHash                 string   `json:"tx_hash"`
	Status                 string   `json:"status"`
}

func (q *Queries) RegisterTransaction(ctx context.Context, arg RegisterTransactionParams) (WatcherTransaction, error) {
	row := q.queryRow(ctx, q.registerTransactionStmt, registerTransaction,
		arg.SerializedMessage,
		arg.LatestValidBlockHeight,
		pq.Array(arg.AccountAliases),
		arg.TxHash,
		arg.Status,
	)
	var i WatcherTransaction
	err := row.Scan(
		&i.ID,
		&i.SerializedMessage,
		&i.LatestValidBlockHeight,
		pq.Array(&i.AccountAliases),
		&i.TxHash,
		&i.Status,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Retries,
	)
	return i, err
}

const registerTxRetry = `-- name: RegisterTxRetry :exec
UPDATE watcher_transactions
SET latest_valid_block_height = $1,
    tx_hash = $2,
    retries = retries + 1
WHERE id = $3
`

type RegisterTxRetryParams struct {
	LatestValidBlockHeight int64     `json:"latest_valid_block_height"`
	TxHash                 string    `json:"tx_hash"`
	ID                     uuid.UUID `json:"id"`
}

func (q *Queries) RegisterTxRetry(ctx context.Context, arg RegisterTxRetryParams) error {
	_, err := q.exec(ctx, q.registerTxRetryStmt, registerTxRetry, arg.LatestValidBlockHeight, arg.TxHash, arg.ID)
	return err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :exec
UPDATE watcher_transactions
SET status = $1
WHERE id = $2
`

type UpdateTransactionStatusParams struct {
	Status string    `json:"status"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) error {
	_, err := q.exec(ctx, q.updateTransactionStatusStmt, updateTransactionStatus, arg.Status, arg.ID)
	return err
}
