// Code generated by sqlc. DO NOT EDIT.
// source: nfts.sql

package repository

import (
	"context"

	"github.com/lib/pq"
)

const addNFT = `-- name: AddNFT :one
INSERT INTO unity_game_nfts (id, nft_type, allowed_levels)  
VALUES ($1, $2, $3) RETURNING id, nft_type, allowed_levels, deleted_at
`

type AddNFTParams struct {
	ID            string   `json:"id"`
	NftType       string   `json:"nft_type"`
	AllowedLevels []string `json:"allowed_levels"`
}

func (q *Queries) AddNFT(ctx context.Context, arg AddNFTParams) (UnityGameNft, error) {
	row := q.queryRow(ctx, q.addNFTStmt, addNFT, arg.ID, arg.NftType, pq.Array(arg.AllowedLevels))
	var i UnityGameNft
	err := row.Scan(
		&i.ID,
		&i.NftType,
		pq.Array(&i.AllowedLevels),
		&i.DeletedAt,
	)
	return i, err
}

const deleteNFT = `-- name: DeleteNFT :exec
DELETE FROM unity_game_nfts WHERE id = $1
`

func (q *Queries) DeleteNFT(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteNFTStmt, deleteNFT, id)
	return err
}

const getNFT = `-- name: GetNFT :one
SELECT id, nft_type, allowed_levels, deleted_at FROM unity_game_nfts WHERE id = $1
`

func (q *Queries) GetNFT(ctx context.Context, id string) (UnityGameNft, error) {
	row := q.queryRow(ctx, q.getNFTStmt, getNFT, id)
	var i UnityGameNft
	err := row.Scan(
		&i.ID,
		&i.NftType,
		pq.Array(&i.AllowedLevels),
		&i.DeletedAt,
	)
	return i, err
}

const getNFTs = `-- name: GetNFTs :many
SELECT id, nft_type, allowed_levels, deleted_at FROM unity_game_nfts LIMIT $1 OFFSET $2
`

type GetNFTsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetNFTs(ctx context.Context, arg GetNFTsParams) ([]UnityGameNft, error) {
	rows, err := q.query(ctx, q.getNFTsStmt, getNFTs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnityGameNft
	for rows.Next() {
		var i UnityGameNft
		if err := rows.Scan(
			&i.ID,
			&i.NftType,
			pq.Array(&i.AllowedLevels),
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNFTsByTypeAndLevel = `-- name: GetNFTsByTypeAndLevel :many
SELECT id, nft_type, allowed_levels, deleted_at FROM unity_game_nfts WHERE nft_type = $1 AND allowed_levels @> $2
`

type GetNFTsByTypeAndLevelParams struct {
	NftType       string   `json:"nft_type"`
	AllowedLevels []string `json:"allowed_levels"`
}

func (q *Queries) GetNFTsByTypeAndLevel(ctx context.Context, arg GetNFTsByTypeAndLevelParams) ([]UnityGameNft, error) {
	rows, err := q.query(ctx, q.getNFTsByTypeAndLevelStmt, getNFTsByTypeAndLevel, arg.NftType, pq.Array(arg.AllowedLevels))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnityGameNft
	for rows.Next() {
		var i UnityGameNft
		if err := rows.Scan(
			&i.ID,
			&i.NftType,
			pq.Array(&i.AllowedLevels),
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteNFT = `-- name: SoftDeleteNFT :exec
UPDATE unity_game_nfts SET deleted_at = now() WHERE id = $1
`

func (q *Queries) SoftDeleteNFT(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.softDeleteNFTStmt, softDeleteNFT, id)
	return err
}

const updateNFT = `-- name: UpdateNFT :exec
UPDATE unity_game_nfts SET nft_type = $1, allowed_levels = $2 WHERE id = $3
`

type UpdateNFTParams struct {
	NftType       string   `json:"nft_type"`
	AllowedLevels []string `json:"allowed_levels"`
	ID            string   `json:"id"`
}

func (q *Queries) UpdateNFT(ctx context.Context, arg UpdateNFTParams) error {
	_, err := q.exec(ctx, q.updateNFTStmt, updateNFT, arg.NftType, pq.Array(arg.AllowedLevels), arg.ID)
	return err
}
