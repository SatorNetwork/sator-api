// Code generated by sqlc. DO NOT EDIT.
// source: invitations.sql

package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const acceptInvitationByInviteeEmail = `-- name: AcceptInvitationByInviteeEmail :exec
UPDATE invitations
SET accepted_by = $1,
    accepted_at = $2
WHERE id = $3
`

type AcceptInvitationByInviteeEmailParams struct {
	AcceptedBy uuid.UUID    `json:"accepted_by"`
	AcceptedAt sql.NullTime `json:"accepted_at"`
	ID         uuid.UUID    `json:"id"`
}

func (q *Queries) AcceptInvitationByInviteeEmail(ctx context.Context, arg AcceptInvitationByInviteeEmailParams) error {
	_, err := q.exec(ctx, q.acceptInvitationByInviteeEmailStmt, acceptInvitationByInviteeEmail, arg.AcceptedBy, arg.AcceptedAt, arg.ID)
	return err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO invitations (email, invited_by)
VALUES ($1, $2) RETURNING id, email, invited_by, invited_at, accepted_by, accepted_at, reward_received
`

type CreateInvitationParams struct {
	Email     string    `json:"email"`
	InvitedBy uuid.UUID `json:"invited_by"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Invitation, error) {
	row := q.queryRow(ctx, q.createInvitationStmt, createInvitation, arg.Email, arg.InvitedBy)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.AcceptedBy,
		&i.AcceptedAt,
		&i.RewardReceived,
	)
	return i, err
}

const getInvitationByInviteeEmail = `-- name: GetInvitationByInviteeEmail :one
SELECT id, email, invited_by, invited_at, accepted_by, accepted_at, reward_received
FROM invitations
WHERE email = $1
    LIMIT 1
`

func (q *Queries) GetInvitationByInviteeEmail(ctx context.Context, email string) (Invitation, error) {
	row := q.queryRow(ctx, q.getInvitationByInviteeEmailStmt, getInvitationByInviteeEmail, email)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.AcceptedBy,
		&i.AcceptedAt,
		&i.RewardReceived,
	)
	return i, err
}

const getInvitationByInviteeID = `-- name: GetInvitationByInviteeID :one
SELECT id, email, invited_by, invited_at, accepted_by, accepted_at, reward_received
FROM invitations
WHERE accepted_by = $1
    LIMIT 1
`

func (q *Queries) GetInvitationByInviteeID(ctx context.Context, acceptedBy uuid.UUID) (Invitation, error) {
	row := q.queryRow(ctx, q.getInvitationByInviteeIDStmt, getInvitationByInviteeID, acceptedBy)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.InvitedBy,
		&i.InvitedAt,
		&i.AcceptedBy,
		&i.AcceptedAt,
		&i.RewardReceived,
	)
	return i, err
}

const getInvitations = `-- name: GetInvitations :many
SELECT id, email, invited_by, invited_at, accepted_by, accepted_at, reward_received
FROM invitations
ORDER BY invited_at DESC
`

func (q *Queries) GetInvitations(ctx context.Context) ([]Invitation, error) {
	rows, err := q.query(ctx, q.getInvitationsStmt, getInvitations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invitation
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.AcceptedBy,
			&i.AcceptedAt,
			&i.RewardReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationsByInviterID = `-- name: GetInvitationsByInviterID :many
SELECT id, email, invited_by, invited_at, accepted_by, accepted_at, reward_received
FROM invitations
WHERE invited_by = $1
ORDER BY invited_at DESC
`

func (q *Queries) GetInvitationsByInviterID(ctx context.Context, invitedBy uuid.UUID) ([]Invitation, error) {
	rows, err := q.query(ctx, q.getInvitationsByInviterIDStmt, getInvitationsByInviterID, invitedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invitation
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.AcceptedBy,
			&i.AcceptedAt,
			&i.RewardReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationsPaginated = `-- name: GetInvitationsPaginated :many
SELECT id, email, invited_by, invited_at, accepted_by, accepted_at, reward_received
FROM invitations
ORDER BY invited_at DESC
LIMIT $1 OFFSET $2
`

type GetInvitationsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetInvitationsPaginated(ctx context.Context, arg GetInvitationsPaginatedParams) ([]Invitation, error) {
	rows, err := q.query(ctx, q.getInvitationsPaginatedStmt, getInvitationsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invitation
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.InvitedBy,
			&i.InvitedAt,
			&i.AcceptedBy,
			&i.AcceptedAt,
			&i.RewardReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setRewardReceived = `-- name: SetRewardReceived :exec
UPDATE invitations
SET reward_received = $1
WHERE id = $2
`

type SetRewardReceivedParams struct {
	RewardReceived sql.NullBool `json:"reward_received"`
	ID             uuid.UUID    `json:"id"`
}

func (q *Queries) SetRewardReceived(ctx context.Context, arg SetRewardReceivedParams) error {
	_, err := q.exec(ctx, q.setRewardReceivedStmt, setRewardReceived, arg.RewardReceived, arg.ID)
	return err
}
