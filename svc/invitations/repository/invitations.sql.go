// Code generated by sqlc. DO NOT EDIT.
// source: invitations.sql

package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const acceptInvitationByInviteeEmail = `-- name: AcceptInvitationByInviteeEmail :exec
UPDATE invitations
SET accepted_by = $1,
    accepted_at = $2
WHERE invitee_email = $3
`

type AcceptInvitationByInviteeEmailParams struct {
	AcceptedBy   uuid.UUID    `json:"accepted_by"`
	AcceptedAt   sql.NullTime `json:"accepted_at"`
	InviteeEmail string       `json:"invitee_email"`
}

func (q *Queries) AcceptInvitationByInviteeEmail(ctx context.Context, arg AcceptInvitationByInviteeEmailParams) error {
	_, err := q.exec(ctx, q.acceptInvitationByInviteeEmailStmt, acceptInvitationByInviteeEmail, arg.AcceptedBy, arg.AcceptedAt, arg.InviteeEmail)
	return err
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO invitations (invitee_email, normalized_invitee_email, invited_by, accepted_by)
VALUES ($1, $2, $3, uuid_nil()) RETURNING id, invitee_email, normalized_invitee_email, invited_at, invited_by, accepted_at, accepted_by
`

type CreateInvitationParams struct {
	InviteeEmail           string    `json:"invitee_email"`
	NormalizedInviteeEmail string    `json:"normalized_invitee_email"`
	InvitedBy              uuid.UUID `json:"invited_by"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Invitation, error) {
	row := q.queryRow(ctx, q.createInvitationStmt, createInvitation, arg.InviteeEmail, arg.NormalizedInviteeEmail, arg.InvitedBy)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.InviteeEmail,
		&i.NormalizedInviteeEmail,
		&i.InvitedAt,
		&i.InvitedBy,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const getInvitationByInviteeEmail = `-- name: GetInvitationByInviteeEmail :one
SELECT id, invitee_email, normalized_invitee_email, invited_at, invited_by, accepted_at, accepted_by
FROM invitations
WHERE normalized_invitee_email = $1
    LIMIT 1
`

func (q *Queries) GetInvitationByInviteeEmail(ctx context.Context, normalizedInviteeEmail string) (Invitation, error) {
	row := q.queryRow(ctx, q.getInvitationByInviteeEmailStmt, getInvitationByInviteeEmail, normalizedInviteeEmail)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.InviteeEmail,
		&i.NormalizedInviteeEmail,
		&i.InvitedAt,
		&i.InvitedBy,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const getInvitationByInviteeID = `-- name: GetInvitationByInviteeID :one
SELECT id, invitee_email, normalized_invitee_email, invited_at, invited_by, accepted_at, accepted_by
FROM invitations
WHERE accepted_by = $1
    LIMIT 1
`

func (q *Queries) GetInvitationByInviteeID(ctx context.Context, acceptedBy uuid.UUID) (Invitation, error) {
	row := q.queryRow(ctx, q.getInvitationByInviteeIDStmt, getInvitationByInviteeID, acceptedBy)
	var i Invitation
	err := row.Scan(
		&i.ID,
		&i.InviteeEmail,
		&i.NormalizedInviteeEmail,
		&i.InvitedAt,
		&i.InvitedBy,
		&i.AcceptedAt,
		&i.AcceptedBy,
	)
	return i, err
}

const getInvitations = `-- name: GetInvitations :many
SELECT id, invitee_email, normalized_invitee_email, invited_at, invited_by, accepted_at, accepted_by
FROM invitations
ORDER BY invited_at DESC
`

func (q *Queries) GetInvitations(ctx context.Context) ([]Invitation, error) {
	rows, err := q.query(ctx, q.getInvitationsStmt, getInvitations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invitation
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.InviteeEmail,
			&i.NormalizedInviteeEmail,
			&i.InvitedAt,
			&i.InvitedBy,
			&i.AcceptedAt,
			&i.AcceptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationsByInvitedByID = `-- name: GetInvitationsByInvitedByID :many
SELECT id, invitee_email, normalized_invitee_email, invited_at, invited_by, accepted_at, accepted_by
FROM invitations
WHERE invited_by = $1
ORDER BY invited_at DESC
`

func (q *Queries) GetInvitationsByInvitedByID(ctx context.Context, invitedBy uuid.UUID) ([]Invitation, error) {
	rows, err := q.query(ctx, q.getInvitationsByInvitedByIDStmt, getInvitationsByInvitedByID, invitedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invitation
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.InviteeEmail,
			&i.NormalizedInviteeEmail,
			&i.InvitedAt,
			&i.InvitedBy,
			&i.AcceptedAt,
			&i.AcceptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationsPaginated = `-- name: GetInvitationsPaginated :many
SELECT id, invitee_email, normalized_invitee_email, invited_at, invited_by, accepted_at, accepted_by
FROM invitations
ORDER BY invited_at DESC
LIMIT $1 OFFSET $2
`

type GetInvitationsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetInvitationsPaginated(ctx context.Context, arg GetInvitationsPaginatedParams) ([]Invitation, error) {
	rows, err := q.query(ctx, q.getInvitationsPaginatedStmt, getInvitationsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invitation
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.InviteeEmail,
			&i.NormalizedInviteeEmail,
			&i.InvitedAt,
			&i.InvitedBy,
			&i.AcceptedAt,
			&i.AcceptedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
