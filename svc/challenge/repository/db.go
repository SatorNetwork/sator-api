// Code generated by sqlc. DO NOT EDIT.

package repository

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.addChallengeStmt, err = db.PrepareContext(ctx, addChallenge); err != nil {
		return nil, fmt.Errorf("error preparing query AddChallenge: %w", err)
	}
	if q.deleteChallengeByIDStmt, err = db.PrepareContext(ctx, deleteChallengeByID); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteChallengeByID: %w", err)
	}
	if q.getChallengeByEpisodeIDStmt, err = db.PrepareContext(ctx, getChallengeByEpisodeID); err != nil {
		return nil, fmt.Errorf("error preparing query GetChallengeByEpisodeID: %w", err)
	}
	if q.getChallengeByIDStmt, err = db.PrepareContext(ctx, getChallengeByID); err != nil {
		return nil, fmt.Errorf("error preparing query GetChallengeByID: %w", err)
	}
	if q.getChallengesStmt, err = db.PrepareContext(ctx, getChallenges); err != nil {
		return nil, fmt.Errorf("error preparing query GetChallenges: %w", err)
	}
	if q.updateChallengeStmt, err = db.PrepareContext(ctx, updateChallenge); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateChallenge: %w", err)
	}
	return &q, nil
}

func (q *Queries) Close() error {
	var err error
	if q.addChallengeStmt != nil {
		if cerr := q.addChallengeStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing addChallengeStmt: %w", cerr)
		}
	}
	if q.deleteChallengeByIDStmt != nil {
		if cerr := q.deleteChallengeByIDStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteChallengeByIDStmt: %w", cerr)
		}
	}
	if q.getChallengeByEpisodeIDStmt != nil {
		if cerr := q.getChallengeByEpisodeIDStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getChallengeByEpisodeIDStmt: %w", cerr)
		}
	}
	if q.getChallengeByIDStmt != nil {
		if cerr := q.getChallengeByIDStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getChallengeByIDStmt: %w", cerr)
		}
	}
	if q.getChallengesStmt != nil {
		if cerr := q.getChallengesStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getChallengesStmt: %w", cerr)
		}
	}
	if q.updateChallengeStmt != nil {
		if cerr := q.updateChallengeStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateChallengeStmt: %w", cerr)
		}
	}
	return err
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db                          DBTX
	tx                          *sql.Tx
	addChallengeStmt            *sql.Stmt
	deleteChallengeByIDStmt     *sql.Stmt
	getChallengeByEpisodeIDStmt *sql.Stmt
	getChallengeByIDStmt        *sql.Stmt
	getChallengesStmt           *sql.Stmt
	updateChallengeStmt         *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:                          tx,
		tx:                          tx,
		addChallengeStmt:            q.addChallengeStmt,
		deleteChallengeByIDStmt:     q.deleteChallengeByIDStmt,
		getChallengeByEpisodeIDStmt: q.getChallengeByEpisodeIDStmt,
		getChallengeByIDStmt:        q.getChallengeByIDStmt,
		getChallengesStmt:           q.getChallengesStmt,
		updateChallengeStmt:         q.updateChallengeStmt,
	}
}
