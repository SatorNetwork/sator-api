// Code generated by sqlc. DO NOT EDIT.
// source: episode_access.sql

package repository

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addEpisodeAccessData = `-- name: AddEpisodeAccessData :one
INSERT INTO episode_access (episode_id, user_id, activated_at)
VALUES ($1, $2, $3) RETURNING episode_id, user_id, activated_at
`

type AddEpisodeAccessDataParams struct {
	EpisodeID   uuid.UUID    `json:"episode_id"`
	UserID      uuid.UUID    `json:"user_id"`
	ActivatedAt sql.NullTime `json:"activated_at"`
}

func (q *Queries) AddEpisodeAccessData(ctx context.Context, arg AddEpisodeAccessDataParams) (EpisodeAccess, error) {
	row := q.queryRow(ctx, q.addEpisodeAccessDataStmt, addEpisodeAccessData, arg.EpisodeID, arg.UserID, arg.ActivatedAt)
	var i EpisodeAccess
	err := row.Scan(&i.EpisodeID, &i.UserID, &i.ActivatedAt)
	return i, err
}

const deleteEpisodeAccessData = `-- name: DeleteEpisodeAccessData :exec
DELETE FROM episode_access
WHERE episode_id = $1 AND user_id = $2
`

type DeleteEpisodeAccessDataParams struct {
	EpisodeID uuid.UUID `json:"episode_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteEpisodeAccessData(ctx context.Context, arg DeleteEpisodeAccessDataParams) error {
	_, err := q.exec(ctx, q.deleteEpisodeAccessDataStmt, deleteEpisodeAccessData, arg.EpisodeID, arg.UserID)
	return err
}

const doesUserHaveAccessToEpisode = `-- name: DoesUserHaveAccessToEpisode :one
SELECT EXISTS (
    SELECT episode_id, user_id, activated_at 
    FROM episode_access
    WHERE episode_id = $1 AND user_id = $2 AND activated_at > $3
)
`

type DoesUserHaveAccessToEpisodeParams struct {
	EpisodeID      uuid.UUID    `json:"episode_id"`
	UserID         uuid.UUID    `json:"user_id"`
	NotEarlierThan sql.NullTime `json:"not_earlier_than"`
}

func (q *Queries) DoesUserHaveAccessToEpisode(ctx context.Context, arg DoesUserHaveAccessToEpisodeParams) (bool, error) {
	row := q.queryRow(ctx, q.doesUserHaveAccessToEpisodeStmt, doesUserHaveAccessToEpisode, arg.EpisodeID, arg.UserID, arg.NotEarlierThan)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getEpisodeAccessData = `-- name: GetEpisodeAccessData :one
SELECT episode_id, user_id, activated_at
FROM episode_access
WHERE episode_id = $1 AND user_id = $2
ORDER BY activated_at DESC
LIMIT 1
`

type GetEpisodeAccessDataParams struct {
	EpisodeID uuid.UUID `json:"episode_id"`
	UserID    uuid.UUID `json:"user_id"`
}

func (q *Queries) GetEpisodeAccessData(ctx context.Context, arg GetEpisodeAccessDataParams) (EpisodeAccess, error) {
	row := q.queryRow(ctx, q.getEpisodeAccessDataStmt, getEpisodeAccessData, arg.EpisodeID, arg.UserID)
	var i EpisodeAccess
	err := row.Scan(&i.EpisodeID, &i.UserID, &i.ActivatedAt)
	return i, err
}

const updateEpisodeAccessData = `-- name: UpdateEpisodeAccessData :exec
UPDATE episode_access
SET activated_at = $1
WHERE episode_id = $2 AND user_id = $3
`

type UpdateEpisodeAccessDataParams struct {
	ActivatedAt sql.NullTime `json:"activated_at"`
	EpisodeID   uuid.UUID    `json:"episode_id"`
	UserID      uuid.UUID    `json:"user_id"`
}

func (q *Queries) UpdateEpisodeAccessData(ctx context.Context, arg UpdateEpisodeAccessDataParams) error {
	_, err := q.exec(ctx, q.updateEpisodeAccessDataStmt, updateEpisodeAccessData, arg.ActivatedAt, arg.EpisodeID, arg.UserID)
	return err
}
