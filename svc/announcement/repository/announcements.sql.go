// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: announcements.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const cleanUpAnnouncements = `-- name: CleanUpAnnouncements :exec
DELETE FROM announcements
`

func (q *Queries) CleanUpAnnouncements(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanUpAnnouncementsStmt, cleanUpAnnouncements)
	return err
}

const cleanUpReadAnnouncements = `-- name: CleanUpReadAnnouncements :exec
DELETE FROM read_announcements
`

func (q *Queries) CleanUpReadAnnouncements(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanUpReadAnnouncementsStmt, cleanUpReadAnnouncements)
	return err
}

const createAnnouncement = `-- name: CreateAnnouncement :one
INSERT INTO announcements (
    title,
    description,
    action_url,
    starts_at,
    ends_at,
    type,
    type_specific_params
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
) RETURNING id, title, description, action_url, starts_at, ends_at, updated_at, created_at, type, type_specific_params
`

type CreateAnnouncementParams struct {
	Title              string    `json:"title"`
	Description        string    `json:"description"`
	ActionUrl          string    `json:"action_url"`
	StartsAt           time.Time `json:"starts_at"`
	EndsAt             time.Time `json:"ends_at"`
	Type               string    `json:"type"`
	TypeSpecificParams string    `json:"type_specific_params"`
}

func (q *Queries) CreateAnnouncement(ctx context.Context, arg CreateAnnouncementParams) (Announcement, error) {
	row := q.queryRow(ctx, q.createAnnouncementStmt, createAnnouncement,
		arg.Title,
		arg.Description,
		arg.ActionUrl,
		arg.StartsAt,
		arg.EndsAt,
		arg.Type,
		arg.TypeSpecificParams,
	)
	var i Announcement
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ActionUrl,
		&i.StartsAt,
		&i.EndsAt,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Type,
		&i.TypeSpecificParams,
	)
	return i, err
}

const deleteAnnouncementByID = `-- name: DeleteAnnouncementByID :exec
DELETE FROM announcements
WHERE id = $1
`

func (q *Queries) DeleteAnnouncementByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteAnnouncementByIDStmt, deleteAnnouncementByID, id)
	return err
}

const getAnnouncementByID = `-- name: GetAnnouncementByID :one
SELECT id, title, description, action_url, starts_at, ends_at, updated_at, created_at, type, type_specific_params FROM announcements
WHERE id = $1
`

func (q *Queries) GetAnnouncementByID(ctx context.Context, id uuid.UUID) (Announcement, error) {
	row := q.queryRow(ctx, q.getAnnouncementByIDStmt, getAnnouncementByID, id)
	var i Announcement
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ActionUrl,
		&i.StartsAt,
		&i.EndsAt,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.Type,
		&i.TypeSpecificParams,
	)
	return i, err
}

const listActiveAnnouncements = `-- name: ListActiveAnnouncements :many
SELECT id, title, description, action_url, starts_at, ends_at, updated_at, created_at, type, type_specific_params FROM announcements
WHERE starts_at <= NOW() AND NOW() <= ends_at
LIMIT $2 OFFSET $1
`

type ListActiveAnnouncementsParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

func (q *Queries) ListActiveAnnouncements(ctx context.Context, arg ListActiveAnnouncementsParams) ([]Announcement, error) {
	rows, err := q.query(ctx, q.listActiveAnnouncementsStmt, listActiveAnnouncements, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Announcement
	for rows.Next() {
		var i Announcement
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ActionUrl,
			&i.StartsAt,
			&i.EndsAt,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Type,
			&i.TypeSpecificParams,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAnnouncements = `-- name: ListAnnouncements :many
SELECT id, title, description, action_url, starts_at, ends_at, updated_at, created_at, type, type_specific_params FROM announcements
LIMIT $2 OFFSET $1
`

type ListAnnouncementsParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

func (q *Queries) ListAnnouncements(ctx context.Context, arg ListAnnouncementsParams) ([]Announcement, error) {
	rows, err := q.query(ctx, q.listAnnouncementsStmt, listAnnouncements, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Announcement
	for rows.Next() {
		var i Announcement
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ActionUrl,
			&i.StartsAt,
			&i.EndsAt,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Type,
			&i.TypeSpecificParams,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnreadAnnouncements = `-- name: ListUnreadAnnouncements :many
SELECT id, title, description, action_url, starts_at, ends_at, updated_at, created_at, type, type_specific_params FROM announcements WHERE id IN (
    SELECT id
    FROM announcements
        EXCEPT
    SELECT announcement_id
    FROM read_announcements
    WHERE user_id = $1
) AND NOW() <= ends_at
LIMIT $3 OFFSET $2
`

type ListUnreadAnnouncementsParams struct {
	UserID    uuid.UUID `json:"user_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

func (q *Queries) ListUnreadAnnouncements(ctx context.Context, arg ListUnreadAnnouncementsParams) ([]Announcement, error) {
	rows, err := q.query(ctx, q.listUnreadAnnouncementsStmt, listUnreadAnnouncements, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Announcement
	for rows.Next() {
		var i Announcement
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ActionUrl,
			&i.StartsAt,
			&i.EndsAt,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Type,
			&i.TypeSpecificParams,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAnnouncementByID = `-- name: UpdateAnnouncementByID :exec
UPDATE announcements
SET
    title = $1,
    description = $2,
    action_url = $3,
    starts_at = $4,
    ends_at = $5,
    type = $6,
    type_specific_params = $7
WHERE id = $8
`

type UpdateAnnouncementByIDParams struct {
	Title              string    `json:"title"`
	Description        string    `json:"description"`
	ActionUrl          string    `json:"action_url"`
	StartsAt           time.Time `json:"starts_at"`
	EndsAt             time.Time `json:"ends_at"`
	Type               string    `json:"type"`
	TypeSpecificParams string    `json:"type_specific_params"`
	ID                 uuid.UUID `json:"id"`
}

func (q *Queries) UpdateAnnouncementByID(ctx context.Context, arg UpdateAnnouncementByIDParams) error {
	_, err := q.exec(ctx, q.updateAnnouncementByIDStmt, updateAnnouncementByID,
		arg.Title,
		arg.Description,
		arg.ActionUrl,
		arg.StartsAt,
		arg.EndsAt,
		arg.Type,
		arg.TypeSpecificParams,
		arg.ID,
	)
	return err
}
